```haskell
type Algebra f a = f a -> a

newtype Mu f = InF { outF :: f (Mu f) }
newtype Fix f = Fx (f (Fix f))

cata :: Functor f => Algebra f a -> Mu f -> a
cata f = f . fmap (cata f) . outF
```

Algebra allows us to perform calculations with numbers and symbols. F-algebras reduce the notion of an algebra to the bare minimum. The basic requirements are: a functor, a type and a function. 

Two essential aspects of an algebra:
1. the ability to form expressions
2. the ability to evaluate expressions

Haskell grammar

```
data Expr = Const Int
          | Add Expr Expr
          | Mul Expr Expr
```
recursive tree. Recursion can be abstratected away to uncover the primitives behind the expressions. Define a non-recursive function and the find its fixed point.

define a type constructor

```
data ExprF a = Const Int
             | Add a a
             | Mul a a
```

recursive structure of Expr can be generated by repeatedly applying ExprF to itself as in `ExprF (ExprF (ExprF a))`

`newtype Fix f = Fx (f (Fix f))`

data constructor of `Fix : Fx` can be treated as a function that takes an element of type `f (Fix f)` and produces `Fix f`
`Fx :: f (Fix f) -> Fix f`

redefine Expr as a fixed point of ExprF

`type Expr = Fix ExprF`

there is one constructor of Expr that doesn't depened on `a`? `Const Int`

```
val :: Fix ExprF
val = Fx (Const 12)
```
this is a leaf expr (bottom node)

```
Fx $ (Fx (Const 1)) `Add` (Fx (Const 12))
```

evaluation is a recipe for extracting a single value from an expression. Evaluation has to proceed recursibely becasue the expressiosn are defined recursively. We need an evaluation strategy for each top level constructor (for each constructor in ExprF). 

`alg` non-recursive top-level evaluator
`eval` recursive evaluator, the Functor/fmap definition, endofunctor

```
instance Functor ExprF where
  fmap f (Const i) = Const i
  fmap f (Add a b) = Add (f a) (f b)
  fmap f (Mul a b) = Mul (f a) (f b)
```
Int is the carrier type of the algebra, define alg from the image of Int under the functor ExprF back to Int

```
alg :: ExprF Int -> Int
alg (Const i) = i
alg (Add a b) = a + b
alg (Mul a b) = a * b
```


```
alg' :: ExprF String -> String
alg' (Const i)   = [chr (ord 'a' + i)]
alg' (x `Add` y) = x ++ y
alg' (x `Mul` y) = concat [[a, b] | a <- x, b <- y]
```


F-algebra:
1. an endofunctor F in a category C
2. and object A in that category C
3. a morphims from F(A) to A

functor `f`, carrier type `a` and function `f a -> a`

```
type Algebra f a = f a -> a
type SimpleA = Algebra ExprF Int

alg :: SimpleA
alg (Const i) = i
alg (Add a b) = a + b
alg (Mul a b) = a * b
```

eval can be defined in a very general way via initial algebra

give any functor `f` Fix defineds a new unique type `Fix f`

```
type ExprInitAlg = Algebra ExprF (Fix ExprF)
ex_init_alg :: ExprF (Fix ExprF) -> Fix ExprF
ex_init_alg = Fx
```
evaluator does not reduce anything, it is not lossy. it preserves all the information. The algebra here is at least as powerful as all other algebras based on the same function, that is why it is the initial algebra. 

initial : there exists a unique homomorphism from it to any othe algebra based on the same functor

```
g :: Fix f -> a
alg :: f a -> a
```
`g` law: it should not matter wheter we first use the inital algebra's evaluator and then apply g or if you apply g and then the second evaluator alg

first eval: Fx to go from `f (Fix f)` to `Fix f`. then `g` takes `Fix f` to a
second: `fmap g` to map `f (Fix f)` to `f a`, followed by alg from `f a` to `a`


`Fx` is a loseless transformation and it can be inverted. inverse of `Fx` is `unFix`
```
unFix :: Fix f -> f (Fix f)
unFix (Fx x) = x
```

```
g :: Fix f -> a
g = alg . (fmap g) . unFix
```

```
cata :: Functor f => (f a -> a) -> Fix f -> a
cata alg = alg . fmap (cata alg) . unFix
```


```
f (Fix f) -- (fmap g) --> f a
   ↑                       |
   |                       |
(unFix)                  (alg)
   |                       |
   |                       ↓
(Fix f)   -- (g) ------->  a   
```


```
type SimpleA = Algebra ExprF Int

alg :: SimpleA
alg (Const i)   = i
alg (x `Add` y) = x + y
alg (x `Mul` y) = x * y

eval :: Fix ExprF -> Int
-- eval = cata alg = alg . fmap (cata alg) . unFix
eval = alg . fmap eval . unFix 
```


```
data ExprF r = Const Int
             | Add r r
             | Mul r r

instance Functor ExprF where 
  fmap f (Const i) = Const i
  fmap f (Add a b) = Add (f a) (f b)
  fmap f (Mul a b) = Mul (f a) (f b)
  
newtype Fix f = Fx (f (Fix f))

unFix :: Fix f -> f (Fix f)
unFix (Fx x) = x

cata :: Functor f => (f a -> a) -> Fix f -> a
cata alg = alg . fmap (cata alg) . unFix

alg :: ExprF Int -> Int
alg (Const i)   = i
alg (x `Add` y) = x + y
alg (x `Mul` y) = x * y

algConstCount :: ExprF Int -> Int
algConstCount (Const _)   = 1
algConstCount (x `Add` y) = x + y
algConstCount (x `Mul` y) = x + y

algAddCount :: ExprF Int -> Int
algAddCount (Const _)   = 0 -- don't count the leaf
algAddCount (x `Add` y) = x + y + 1 -- count this one
algAddCount (x `Mul` y) = x + y

eval :: Fix ExprF -> Int
eval = cata alg

eval2 = cata algConstCount
eval3 = cata algAddCount

eval2 $ Fx ((Fx ((Fx $ Const 234) `Add` (Fx $ Const 444))) `Add` (Fx $ Const 444))

eval3 $ Fx ((Fx $ Const 234) `Add` (Fx $ Const 444))


testExpr = Fx $ (Fx $ (Fx $ Const 2) `Add` (Fx $ Const 3)) `Mul` (Fx $ Const 4)

main = print $ eval $ testExpr
```


cata morphism for list
```
newtype Fix f = Fx (f (Fix f))

unFix :: Fix f -> f (Fix f)
unFix (Fx x) = x

cata :: Functor f => (f a -> a) -> Fix f -> a
cata alg = alg . fmap (cata alg) . unFix
-- show
data ListF a b = Nil | Cons a b

instance Functor (ListF a) where
    fmap f Nil = Nil
    fmap f (Cons e x) = Cons e (f x)

algSum :: ListF Int Int -> Int
algSum Nil = 0
algSum (Cons e acc) = e + acc

lst :: Fix (ListF Int)
lst = Fx $ Cons 2 (Fx $ Cons 3 (Fx $ Cons 4 (Fx Nil)))

main = do
    print $ (cata algSum) lst
    print $ foldr (\e acc -> e + acc) 0 [2, 3, 4]
```

[Understanding F-Algebras](https://www.schoolofhaskell.com/user/bartosz/understanding-algebras)

[Advanced Functional Programming](http://web.cecs.pdx.edu/~sheard/course/AdvancedFP/notes/CoAlgebras/Code.html), Tim Sheard's course notes.

[Computer Science Stack Exchange - Initial Algebra example](http://cs.stackexchange.com/a/9019)

[Catamorphisms](https://www.schoolofhaskell.com/user/edwardk/recursion-schemes/catamorphisms) by Edward Kmett


## cleanup

Endofunctor: A functor that maps a category to itself
endo-: within, inside
  < Greek, cominbining form of éndon within

addS :: String -> String
addS = ++ "s"

endoF = fmap addS

endoF ["dog","cat","chicken"]
endoF (Just "dog")
endoF (Right "dog")

Initial Algebra: an initial object in cateogry of F-algebras for a given endofunctor F.
  The initiality provides a general framework for induction and recursion.

  Zero in the set of natural numbers

  nil: 1 -> List(A)
  cons: A x List(A) -> List(a)

  foldr

catamorphism
cata-: down, against, back
  < Greek kata-,  combining form of katá down, through, against, according to, towards, during
    cataclysm
    catalog
    catalepsy
    down ( catabolism), away, off ( catalectic), against ( category), according to ( catholic), and thoroughly ( catalogue)
    catapul
    catabolism
    cataplasia
    word-forming element from Latinized form of Greek kata-, before vowels kat-, from kata "down from, down to." Its principal sense is "down," but occasionally it has senses of "against" ( catapult )or "wrongly" ( catachresis ). Also sometimes used as an intensive or with a sense of completion of action ( catalogue ). Very active in ancient Greek, this prefix is found in English mostly in words borrowed through Latin after c.1500.

homomorphism
generalization of folds of lists to arbitrary algebraic data types

dual concept of anamorphism unfolds lists

hylomorphis is the composition of an anamorphism followed by a catamorphism

f algebra

